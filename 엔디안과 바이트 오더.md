P2P 네트워크 코드를 보다가 `binary.BigEndian`이 계속 나왔다. 대충 "바이트 순서" 정도로 알고 있었는데, 왜 하필 BigEndian인지, LittleEndian은 뭔지 제대로 정리하고 싶었다.

블록체인 노드끼리 통신하려면 이 개념을 확실히 알아야 한다. 서로 다른 CPU 아키텍처에서 돌아가는 노드들이 같은 데이터를 주고받으려면 바이트 순서를 맞춰야 하기 때문이다.

---

## 문제의 시작: 숫자를 메모리에 어떻게 저장할까

```go
var num uint32 = 0x12345678
```

이 숫자는 4바이트다. 메모리에 저장할 때 순서가 두 가지 있다.

```
메모리 주소:    0x00    0x01    0x02    0x03
             ┌───────┬───────┬───────┬───────┐
BigEndian:   │ 0x12  │ 0x34  │ 0x56  │ 0x78  │  ← 큰 자릿수가 낮은 주소
             └───────┴───────┴───────┴───────┘

             ┌───────┬───────┬───────┬───────┐
LittleEndian:│ 0x78  │ 0x56  │ 0x34  │ 0x12  │  ← 작은 자릿수가 낮은 주소
             └───────┴───────┴───────┴───────┘
```

사람이 읽기엔 BigEndian이 자연스럽다. 우리가 숫자 쓰는 순서랑 같으니까.

---

## 왜 두 가지가 존재하는가

역사적인 이유다.

| 아키텍처 | 엔디안 |
|----------|--------|
| x86, x86_64 (Intel, AMD) | Little Endian |
| ARM (설정 가능) | 보통 Little Endian |
| SPARC, PowerPC (구형) | Big Endian |
| 네트워크 표준 | Big Endian |

내 노트북(x86_64)은 Little Endian이다. 근데 네트워크로 데이터 보낼 때는 Big Endian을 써야 한다.

---

## Little Endian의 장점

처음엔 "왜 굳이 거꾸로 저장하지?" 싶었는데, 이유가 있다.

```
덧셈할 때:

  0x12345678
+ 0x00000001
────────────

Little Endian이면 낮은 주소부터 계산 가능:
0x78 + 0x01 = 0x79 (캐리 없음, 끝)

Big Endian이면 높은 주소부터 시작해야 함
```

CPU가 연산할 때 Little Endian이 더 효율적인 경우가 있다. 그래서 Intel이 이걸 선택했다.

---

## 네트워크는 왜 Big Endian인가

"Network Byte Order"라고 부른다. RFC 1700에서 정의됐다.

이유는 단순하다. 표준을 정할 때 Big Endian을 쓰는 시스템이 많았고, 사람이 읽기도 편하니까.

```
IP 주소 192.168.1.1을 32비트로:
0xC0A80101

BigEndian으로 저장:
[0xC0, 0xA8, 0x01, 0x01]
= [192, 168, 1, 1]  ← 우리가 읽는 순서 그대로
```

---

## Go에서 엔디안 다루기

`encoding/binary` 패키지를 쓴다.

### 숫자 → 바이트

```go
import "encoding/binary"

var nonce uint64 = 0x123456789ABCDEF0

// BigEndian으로 인코딩
buf := make([]byte, 8)
binary.BigEndian.PutUint64(buf, nonce)
// buf: [0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0]

// LittleEndian으로 인코딩
buf2 := make([]byte, 8)
binary.LittleEndian.PutUint64(buf2, nonce)
// buf2: [0xF0, 0xDE, 0xBC, 0x9A, 0x78, 0x56, 0x34, 0x12]
```

### 바이트 → 숫자

```go
data := []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0}

num := binary.BigEndian.Uint64(data)
// num: 0x123456789ABCDEF0
```

### 다양한 크기

```go
binary.BigEndian.PutUint16(buf, uint16Value)  // 2바이트
binary.BigEndian.PutUint32(buf, uint32Value)  // 4바이트
binary.BigEndian.PutUint64(buf, uint64Value)  // 8바이트
```

---

## 실제 P2P 코드에서

Ping/Pong 메시지 인코딩 예시:

```go
type PingPayload struct {
    Nonce uint64
}

func (p *PingPayload) Encode() []byte {
    buf := make([]byte, 8)
    binary.BigEndian.PutUint64(buf, p.Nonce)
    return buf
}

func DecodePing(data []byte) (*PingPayload, error) {
    if len(data) < 8 {
        return nil, errors.New("data too short")
    }
    return &PingPayload{
        Nonce: binary.BigEndian.Uint64(data),
    }, nil
}
```

왜 BigEndian인가:
- 네트워크 표준
- 다른 언어로 구현된 노드와 호환
- 디버깅할 때 바이트 덤프 읽기 편함

---

## 블록체인에서 엔디안 주의점

### 이더리움은 Big Endian

```go
// go-ethereum/common/bytes.go
func LeftPadBytes(slice []byte, l int) []byte {
    // Big Endian: 왼쪽(높은 자릿수)에 패딩
}
```

트랜잭션 해시, 블록 해시 전부 Big Endian으로 표현한다.

### 비트코인은 혼합

```
블록 해시: Internal Byte Order (Little Endian으로 저장)
RPC 응답: Display Order (Big Endian으로 보여줌)
```

비트코인 블록 탐색기에서 보는 해시랑 실제 저장된 바이트 순서가 다르다. 이거 처음에 헷갈렸다.

---

## 흔한 실수

### 1. 엔디안 안 맞춰서 통신 실패

```go
// 노드 A (Go)
binary.BigEndian.PutUint64(buf, nonce)
send(buf)

// 노드 B (다른 구현체)
// Little Endian으로 읽으면?
nonce := binary.LittleEndian.Uint64(buf)
// 완전히 다른 값이 됨!
```

### 2. 바이트 슬라이스 길이 부족

```go
buf := make([]byte, 4)
binary.BigEndian.PutUint64(buf, num)  // panic! 8바이트 필요한데 4바이트만 있음
```

### 3. 부호 있는 정수 처리

```go
var signed int64 = -1

// 이렇게 하면 안 됨
binary.BigEndian.PutUint64(buf, uint64(signed))  // 동작은 하지만...

// 디코딩할 때 부호 복원 주의
decoded := int64(binary.BigEndian.Uint64(buf))
```

---

## 디버깅 팁

바이트 덤프 볼 때:

```go
import "encoding/hex"

data := []byte{0x12, 0x34, 0x56, 0x78}
fmt.Println(hex.EncodeToString(data))
// 출력: 12345678

// BigEndian으로 읽으면
num := binary.BigEndian.Uint32(data)
fmt.Printf("0x%X\n", num)
// 출력: 0x12345678  ← 보이는 그대로
```

Big Endian이면 hex 덤프가 숫자랑 같은 순서라서 디버깅이 편하다.

---

## 정리

| 상황 | 사용할 엔디안 |
|------|--------------|
| 네트워크 통신 | Big Endian |
| 파일 포맷 (정의된 대로) | 명세 따라 |
| 로컬 계산 | 신경 안 써도 됨 (CPU가 알아서) |

블록체인 P2P 프로토콜 구현할 때:
1. 명세에서 바이트 오더 확인
2. 대부분 Big Endian (Network Byte Order)
3. `encoding/binary` 패키지로 변환
4. 버퍼 크기 항상 확인

엔디안 안 맞추면 노드끼리 통신이 안 된다. 단순한 개념인데 실수하면 디버깅이 어렵다. 바이트 레벨에서 뭔가 이상하면 엔디안부터 의심해보자.

---

## 참고

- encoding/binary 패키지: https://pkg.go.dev/encoding/binary
- RFC 1700 (Network Byte Order): https://tools.ietf.org/html/rfc1700
- Geth RLP 인코딩: https://github.com/ethereum/go-ethereum/tree/master/rlp
