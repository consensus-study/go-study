# 비트 NOT 연산으로 uint64 최대값 구하기

## 발견 계기

코드 리뷰하다가 이런 코드를 봤다.

```go
var lowestPrice uint64 = ^uint64(0)
```

처음엔 뭔 소린가 싶었는데, 알고 보니 uint64의 최대값을 구하는 트릭이었다.

## 동작 원리

Go에서 `^`는 단항 연산자로 쓰이면 비트 NOT (비트 반전) 연산이다.

```go
uint64(0)   // 모든 비트가 0
^uint64(0)  // 모든 비트가 1 (= uint64 최대값)
```

64비트로 표현하면:

```
0:  0000000000000000000000000000000000000000000000000000000000000000
^0: 1111111111111111111111111111111111111111111111111111111111111111
```

unsigned 정수에서 모든 비트가 1이면 그게 최대값이다. 값으로 치면 18,446,744,073,709,551,615.

## 왜 이런 방식을 쓰는가

Go는 C처럼 `UINT64_MAX` 같은 매크로가 없다. 그래서 예전부터 이런 비트 연산 트릭을 많이 썼던 것 같다.

## 더 나은 방법

사실 `math` 패키지에 상수가 정의되어 있다.

```go
import "math"

var lowestPrice uint64 = math.MaxUint64
```

가독성 면에서는 이게 훨씬 낫다. 다만 비트 연산 버전도 알아두면 남의 코드 읽을 때 당황하지 않는다.

## 사용 예시

최소값을 찾는 알고리즘에서 초기값 설정할 때 자주 쓴다.

```go
var minPrice uint64 = math.MaxUint64

for _, price := range prices {
    if price < minPrice {
        minPrice = price
    }
}
```

초기값을 최대로 잡아놔야 첫 번째 비교에서 무조건 업데이트되니까.

## 참고

- `^`는 이항 연산자로 쓰이면 XOR이다. 헷갈리지 말 것.
- 다른 타입도 마찬가지: `^uint32(0)`, `^uint8(0)` 등
